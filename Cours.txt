ğŸ“Œ 
2.1 Introduction au Shell

Le shell est un interprÃ©teur de commandes, câ€™est-Ã -dire un programme qui lit et exÃ©cute des instructions Ã©crites sous forme de lignes de commande. 
Ce chapitre explique la syntaxe utilisÃ©e par le shell standard (sh), ainsi que son fonctionnement lorsquâ€™il est appelÃ© par des fonctions comme system() ou popen() dÃ©finies dans la norme IEEE Std 1003.1-2001.

Voici comment le shell fonctionne de maniÃ¨re gÃ©nÃ©rale :

    Il lit les commandes Ã  exÃ©cuter depuis un fichier, via lâ€™option -c en ligne de commande, ou par lâ€™intermÃ©diaire des fonctions system() et popen(). 
    Si un fichier commence par #!, le comportement nâ€™est pas garanti (cela dÃ©pend de lâ€™implÃ©mentation).

    Le shell dÃ©coupe lâ€™entrÃ©e en unitÃ©s appelÃ©es jetons (ou tokens), qui peuvent Ãªtre des mots ou des opÃ©rateurs. (Voir la section sur la reconnaissance des tokens.)

    Ensuite, il analyse ces jetons pour former des commandes simples ou composÃ©es. (Voir les sections sur les commandes simples et composÃ©es.)

    Il applique ensuite diverses transformations appelÃ©es expansions (comme lâ€™expansion de variables, de chemins, etc.) pour prÃ©parer la commande et ses arguments.

    Le shell sâ€™occupe aussi de la redirection, câ€™est-Ã -dire lâ€™envoi ou la lecture dâ€™entrÃ©e/sortie vers ou depuis des fichiers. 
    Une fois la redirection dÃ©finie, les opÃ©rateurs correspondants sont supprimÃ©s de la liste des arguments.

    Le shell exÃ©cute ensuite la commande, quâ€™il sâ€™agisse dâ€™une fonction, dâ€™une commande interne, dâ€™un fichier exÃ©cutable ou dâ€™un script. 
    Les arguments sont accessibles via des variables numÃ©rotÃ©es ($1, $2, etc.), et le nom de la commande ou du script est stockÃ© dans $0.

    Enfin, le shell peut attendre que la commande finisse de sâ€™exÃ©cuter, et il rÃ©cupÃ¨re son code de retour (appelÃ© code de sortie), qui indique si tout sâ€™est bien passÃ© ou non.

ğŸ“Œ 2.2 Les guillemets (Quoting)

Dans le shell, les guillemets (ou lâ€™Ã©chappement) servent Ã  neutraliser le comportement spÃ©cial de certains caractÃ¨res ou mots. Cela permet :

    de conserver le sens littÃ©ral de certains caractÃ¨res spÃ©ciaux (au lieu quâ€™ils soient interprÃ©tÃ©s par le shell),

    dâ€™empÃªcher que des mots rÃ©servÃ©s soient traitÃ©s comme des commandes particuliÃ¨res,

    ou encore dâ€™Ã©viter lâ€™expansion de variables et lâ€™exÃ©cution de commandes dans les blocs here-document (voir la section correspondante).

CaractÃ¨res quâ€™il faut obligatoirement protÃ©ger (par des guillemets ou un antislash \) pour quâ€™ils soient pris tels quels :

|  &  ;  <  >  (  )  $  `  \  "  '  (espace)  (tabulation)  (retour Ã  la ligne)

CaractÃ¨res quâ€™il peut Ãªtre nÃ©cessaire de protÃ©ger, selon le contexte :

*   ?   [   #   ~   =   %

Ces derniers ne sont pas toujours spÃ©ciaux, mais peuvent lâ€™Ãªtre selon lâ€™endroit oÃ¹ ils apparaissent ou leur usage (par exemple dans les noms de fichiers ou les expressions rÃ©guliÃ¨res).

Il existe plusieurs maniÃ¨res de protÃ©ger ou Â« citer Â» du texte dans le shell :

    Le caractÃ¨re dâ€™Ã©chappement (\) : Il permet de neutraliser le sens spÃ©cial dâ€™un seul caractÃ¨re. Par exemple, \* empÃªche lâ€™interprÃ©tation du * comme un caractÃ¨re gÃ©nÃ©rique.

    Les guillemets simples (') : Tout ce qui est placÃ© entre des guillemets simples est pris au pied de la lettre, 
    sans aucune interprÃ©tation. MÃªme les variables ($VAR) ou les commandes (\command``) ne seront pas Ã©valuÃ©es.

    Les guillemets doubles (") : Le texte est partiellement protÃ©gÃ©. La plupart des caractÃ¨res spÃ©ciaux sont neutralisÃ©s, 
    mais les variables ($VAR) et les substitutions de commande (\...`ou$(...)`) restent actives.

    Il existe aussi une autre forme de quoting utilisÃ©e dans les here-documents (documents en ligne dans les scripts). 
    Cela permet de prÃ©server le contenu textuel dans certaines situations. (Voir la section Here-Document pour plus de dÃ©tails.)

ğŸ“Œ 2.2.1 CaractÃ¨re dâ€™Ã©chappement (\)

Le backslash (antislash ou \) permet de conserver la valeur littÃ©rale du caractÃ¨re qui le suit, Ã  condition quâ€™il ne soit pas lui-mÃªme entre guillemets.

Exception : si le caractÃ¨re qui suit est un retour Ã  la ligne (<newline>), alors ce couple \ + retour Ã  la ligne est interprÃ©tÃ© par le shell comme une continuitÃ© de ligne. 
Autrement dit, cela permet de couper une commande sur plusieurs lignes sans quâ€™elle soit rÃ©ellement terminÃ©e.

    Dans ce cas, le backslash et le retour Ã  la ligne sont supprimÃ©s avant que la ligne ne soit analysÃ©e, ce qui signifie quâ€™aucun espace nâ€™est insÃ©rÃ© Ã  leur place. 
    Cela veut aussi dire que cette coupure ne peut pas servir de sÃ©parateur entre deux mots.

ğŸ“Œ 2.2.2 Guillemets simples (')

Quand on entoure du texte avec des guillemets simples ('), chaque caractÃ¨re Ã  lâ€™intÃ©rieur est pris exactement tel quel, sans aucune interprÃ©tation par le shell.

Cela veut dire :

    pas dâ€™expansion de variables ($VAR reste littÃ©ralement $VAR),

    pas de substitution de commandes,

    pas de traitement spÃ©cial des caractÃ¨res comme *, ?, etc.

Attention : il nâ€™est pas possible dâ€™inclure un guillemet simple Ã  lâ€™intÃ©rieur dâ€™un bloc entre guillemets simples. Si tu veux utiliser un ' Ã  lâ€™intÃ©rieur, 
tu dois le gÃ©rer autrement (par exemple en fermant les quotes puis en utilisant un \' ou des guillemets doubles).

ğŸ“Œ 2.2.3 Guillemets doubles (")

Encadrer du texte avec des guillemets doubles (") permet de prÃ©server la plupart des caractÃ¨res tels quels, sauf les suivants, qui conservent une signification spÃ©ciale :
$ (dollar)

    Sert toujours Ã  :

        lâ€™expansion de variables ($VAR)

        la substitution de commande ($(commande))

        lâ€™expansion arithmÃ©tique ($((expression)))

    Pour les commandes entre $(...), le shell ignore les guillemets doubles Ã  lâ€™intÃ©rieur et traite normalement le contenu jusquâ€™Ã  la parenthÃ¨se fermante correspondante.

    Dans une construction ${...}, il doit y avoir un nombre pair de guillemets (" ou ') non Ã©chappÃ©s Ã  lâ€™intÃ©rieur. Un backslash (\) peut Ãªtre utilisÃ© pour inclure littÃ©ralement { ou }. La fermeture correcte est dÃ©terminÃ©e selon les rÃ¨gles dâ€™expansion de paramÃ¨tres.

` (accent grave)

    Ce caractÃ¨re garde sa fonction de substitution de commande (ancienne forme : `commande`).

    Le contenu entre les deux accents graves est exÃ©cutÃ©, et remplacÃ© par sa sortie.

    Si une chaÃ®ne (entre ' ou ") commence dans cette sÃ©quence sans se fermer, ou inversement, cela produit un rÃ©sultat non dÃ©fini.

\ (backslash)

    Ã€ lâ€™intÃ©rieur de guillemets doubles, le backslash conserve son rÃ´le seulement devant ces caractÃ¨res :

        $, `, ", \ et le retour Ã  la ligne

    Pour inclure un guillemet double dans une chaÃ®ne entre guillemets doubles, on doit lâ€™Ã©chapper avec un backslash (\").

    ğŸ’¡ Le paramÃ¨tre spÃ©cial $@ a aussi un comportement particulier dans les guillemets doubles (voir section sur les paramÃ¨tres spÃ©ciaux).

ğŸ“Œ 2.3 Reconnaissance des jetons (Token Recognition)

Le shell lit ses entrÃ©es ligne par ligne : depuis un fichier, un terminal (mode interactif), ou une chaÃ®ne (avec sh -c ou system()). Ces lignes peuvent Ãªtre de longueur illimitÃ©e.

Le shell analyse les lignes selon deux modes :

    Reconnaissance ordinaire des jetons (mots, opÃ©rateurs, etc.)

    Traitement des here-documents (texte multiligne aprÃ¨s <<)

When dealing with here-documents:

    Si un jeton de type io_here est dÃ©tectÃ© (ex. : <<EOF), les lignes qui suivent immÃ©diatement le prochain saut de ligne forment un here-document.

    Ces lignes sont analysÃ©es selon des rÃ¨gles spÃ©cifiques (voir Here-Document).

Reconnaissance ordinaire des jetons

Voici les rÃ¨gles appliquÃ©es caractÃ¨re par caractÃ¨re :

    Fin dâ€™entrÃ©e : si lâ€™entrÃ©e est terminÃ©e, le jeton courant est clos. Sâ€™il nâ€™y en a pas, un jeton spÃ©cial de fin dâ€™entrÃ©e est retournÃ©.

    OpÃ©rateurs : si le caractÃ¨re courant peut sâ€™ajouter Ã  une sÃ©quence en cours pour former un opÃ©rateur (comme &&, ||, >>), il est ajoutÃ©. Sinon, lâ€™opÃ©rateur courant est terminÃ©.

    CaractÃ¨res de quoting (\, ', ") non protÃ©gÃ©s :

        Ils dÃ©clenchent un mode de quoting jusquâ€™Ã  la fin de la sÃ©quence concernÃ©e.

        Aucun remplacement (expansion) nâ€™est effectuÃ© Ã  cette Ã©tape.

        Le jeton contient exactement ce qui est entrÃ©, y compris les quotes et les symboles dâ€™expansion, sauf pour le cas \ + retour Ã  la ligne (supprimÃ©s).

    CaractÃ¨res $ et ` non protÃ©gÃ©s :

        Indiquent le dÃ©but dâ€™une expansion (variable, commande ou arithmÃ©tique).

        Le shell lit jusquâ€™Ã  la fin de la sÃ©quence (avec gestion des cas imbriquÃ©s).

        Le texte complet (y compris quotes et symboles) est ajoutÃ© tel quel au jeton.

    DÃ©but dâ€™un nouvel opÃ©rateur non citÃ© :

        Le jeton prÃ©cÃ©dent est terminÃ©.

        Le caractÃ¨re courant commence un nouveau jeton opÃ©rateur.

    Retour Ã  la ligne non citÃ© :

        Termine le jeton en cours.

    Espace ou tabulation non citÃ©s :

        Termine le jeton prÃ©cÃ©dent.

        Le caractÃ¨re courant est ignorÃ©.

    Ajout Ã  un mot :

        Si le caractÃ¨re prÃ©cÃ©dent faisait partie dâ€™un mot, le caractÃ¨re courant lui est ajoutÃ©.

    Commentaires (#) :

        Un # non citÃ© indique que tout le reste de la ligne est un commentaire, sauf le saut de ligne final.

    Autre caractÃ¨re :

        DÃ©marre un nouveau mot.

Une fois le jeton construit, il est ensuite catÃ©gorisÃ© (mot, opÃ©rateur, mot-clÃ©, etc.) selon les rÃ¨gles de la grammaire du shell.